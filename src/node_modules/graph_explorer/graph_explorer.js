const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = graph_explorer

async function graph_explorer (opts) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const on = {
    entries: on_entries,
    style: inject_style
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
    <div class="graph-container"></div>
  `
  const container = shadow.querySelector('.graph-container')

  let all_entries = {}
  const instance_states = {}
  let view = []
  let render_offset = 0
  const view_chunk_size = 20

  const observer = new IntersectionObserver(handle_scroll, {
    root: el,
    threshold: 0.1
  })

  await sdb.watch(onbatch)

  return el

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }

  function on_entries (data) {
    const parsed_data = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    all_entries = parsed_data
    const root_path = '/'
    const root_instance_path = root_path
    if (all_entries[root_path]) {
      if (!instance_states[root_instance_path]) {
        instance_states[root_instance_path] = { expanded_subs: true, expanded_hubs: false }
      }
      build_and_render_view()
    }
  }

  function inject_style (data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data[0])
    shadow.adoptedStyleSheets = [sheet]
  }

  function build_and_render_view () {
    view = []
    const build_view_recursive = (base_path, parent_instance_path, depth, is_last) => {
      const instance_path = `${parent_instance_path}|${base_path}`
      const entry = all_entries[base_path]
      if (!entry) return

      if (!instance_states[instance_path]) {
        instance_states[instance_path] = { expanded_subs: false, expanded_hubs: false }
      }
      const state = instance_states[instance_path]

      view.push({ base_path, instance_path, depth, is_last })

      if (state.expanded_hubs) {
        entry.hubs.forEach((hub_path, i, arr) => {
          build_view_recursive(hub_path, instance_path, depth + 1, i === arr.length - 1)
        })
      }

      if (state.expanded_subs && entry.subs) {
        entry.subs.forEach((sub_path, i, arr) => {
          build_view_recursive(sub_path, instance_path, depth + 1, i === arr.length - 1)
        })
      }
    }

    build_view_recursive('/', '', 0, true)

    container.innerHTML = ''
    render_offset = 0
    render_chunk()
  }

  function render_chunk () {
    const fragment = document.createDocumentFragment()
    const chunk = view.slice(render_offset, render_offset + view_chunk_size)

    chunk.forEach(node_data => {
      const node_el = create_node(node_data)
      fragment.appendChild(node_el)
    })

    container.appendChild(fragment)
    render_offset += chunk.length

    observer.disconnect()
    if (render_offset < view.length) {
      const last_el = container.lastElementChild
      if (last_el) observer.observe(last_el)
    }
  }

  function create_node ({ base_path, instance_path, depth, is_last }) {
    const entry = all_entries[base_path]
    const state = instance_states[instance_path]

    const el = document.createElement('div')
    el.className = `node type-${entry.type}`
    el.style.paddingLeft = `${depth * 20}px`
    el.dataset.instance_path = instance_path

    const has_subs = entry.subs && entry.subs.length > 0
    const prefix_symbol = is_last ? (has_subs && state.expanded_subs ? '└┬' : '└─') : (has_subs && state.expanded_subs ? '├┬' : '├─')

    el.innerHTML = `
      <span class="prefix">${prefix_symbol}</span>
      <span class="icon"></span>
      <span class="name">${entry.name}</span>
    `
    const prefix_el = el.querySelector('.prefix')
    const icon_el = el.querySelector('.icon')

    prefix_el.onclick = () => toggle_hubs(instance_path)
    icon_el.onclick = () => toggle_subs(instance_path)

    return el
  }

  function toggle_subs (instance_path) {
    const state = instance_states[instance_path]
    if (state) {
      state.expanded_subs = !state.expanded_subs
      build_and_render_view()
    }
  }

  function toggle_hubs (instance_path) {
    const state = instance_states[instance_path]
    if (state) {
      state.expanded_hubs = !state.expanded_hubs
      build_and_render_view()
    }
  }

  function handle_scroll (entries) {
    if (entries[0]?.isIntersecting) {
      render_chunk()
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance
  }
  function fallback_instance () {
    return {
      drive: {
        'entries/': {
          'entries.json': {
            $ref: 'entries.json'
          }
        },
        'style/': {
          'theme.css': {
            raw: `
              .graph-container {
                font-family: monospace;
                color: #abb2bf;
                background-color: #282c34;
                padding: 10px;
                height: 500px; /* Or make it flexible */
                overflow: auto;
              }
              .node {
                display: flex;
                align-items: center;
                padding: 1px 0;
                white-space: nowrap;
                cursor: default;
              }
              .prefix, .icon {
                cursor: pointer;
                margin-right: 6px;
              }
              .icon {
                display: inline-block;
                width: 1em;
                text-align: center;
              }
              .name {
                flex-grow: 1;
              }
              .node.type-root > .icon::before { content: '🌳'; }
              .node.type-folder > .icon::before { content: '📁'; }
              .node.type-html-file > .icon::before { content: '📄'; }
              .node.type-js-file > .icon::before { content: '📜'; }
              .node.type-css-file > .icon::before { content: '🎨'; }
              .node.type-json-file > .icon::before { content: '📝'; }
              .node.type-file > .icon::before { content: '📄'; }
            `
          }
        }
      }
    }
  }
}
