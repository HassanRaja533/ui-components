const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = component

async function component (opts, protocol) {
  const { sdb } = await get(opts.sid)
  const { drive } = sdb
  const on = {
    style: inject_style,
    entries: on_entries
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="graph-explorer">
    <div class="root-node">
      <span class="tree-prefix">🪄┬</span>
      <span class="icon-root node-name">root</span>
    </div>
    <div class="explorer-container"></div>
  </div>`
  const graph_explorer = shadow.querySelector('.graph-explorer')
  const tree_prefix = shadow.querySelector('.tree-prefix')
  const container = shadow.querySelector('.explorer-container')
  const root_node = shadow.querySelector('.root-node')

  /******************************************************************************
  Variables for entries and view management. To get data from the state drive.
  ******************************************************************************/
  let entries = {}
  let view = []
  let view_num = 0
  let expanded_subs = new Set(['/']) // Root is expanded by default
  let expanded_supers = new Set([]) // New set for expanded supers
  let init = false
  let ignore_depth = []
  /******************************************************************************
  Intersection Observer to track which nodes are currently in view.
  //TODO: Lazy loading of nodes based on scroll visibility.
  ******************************************************************************/
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const node_id = entry.target.dataset.path
      if (entry.isIntersecting) {
        if (!view.includes(node_id)) {
          view.push(node_id)
          console.log('Node in view:', node_id)
        }
      } else {
        const index = view.indexOf(node_id)
        if (index !== -1) {
          view.splice(index, 1)
          console.log('Node out of view:', node_id)
        }
      }
    })
  }, {
    root: graph_explorer,
    threshold: 0.1
  })

  function calculate_view_num() {
    const container_height = container.clientHeight
    const node_height = 24
    view_num = Math.ceil(container_height / node_height) * 3 || 30
    // console.log('view:', view)
  }


  const subs = await sdb.watch(onbatch)
  graph_explorer.onscroll = () => console.log(view)
  /******************************************************************************
  Setup root node click functionality
  ******************************************************************************/
  root_node.onclick = onroot

  /******************************************************************************
  Resize Observer
  ******************************************************************************/
  const resize_observer = new ResizeObserver(() => {
    calculate_view_num()
    render_visible_nodes()
  })
  resize_observer.observe(container)

  let send = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
  }

  return el

  function onmessage(msg) {
    // console.log('Graph Explorer received message:', msg)
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init && Object.keys(entries).length > 0) {
      calculate_view_num()
      render_visible_nodes()
      init = true
    }
  }

  function fail (data, type) { 
    throw new Error('invalid message', { cause: { data, type } }) 
  }

  function on_entries(data) {
    entries = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
  }
  function inject_style(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }
  function onroot () {
    if (expanded_subs.has('/')) {
      expanded_subs.delete('/')
      tree_prefix.textContent = '🪄─'
    } else {
      expanded_subs.add('/')
      tree_prefix.textContent = '🪄┬'
    }
    render_visible_nodes()
  }
  /******************************************************************************
  Function for the rendering based on the visible nodes.
  ******************************************************************************/
  function render_visible_nodes() {
    container.replaceChildren()
    if (Object.keys(entries).length === 0) return
    
    const visible_entries = calculate_visible_entries()
    ignore_depth = []
    visible_entries.forEach(entry => {
      const node = create_node(entry)
      // console.log(container, node)
      container.appendChild(node)
      observer.observe(node)
    })
  }

  function calculate_visible_entries() {
    const visible_entries = []
    const root_entry = entries["/"]
    if (!root_entry) return visible_entries
    
    if (!expanded_subs.has('/') && !expanded_supers.has('/')) return visible_entries
    
    let queue = []
    if (expanded_subs.has('/')) {
      queue.push(...(root_entry.subs || []).map(path => entries[path]))
    }
    if (expanded_supers.has('/') && root_entry.hubs) {
      queue.push(...root_entry.hubs.map(path => entries[path]))
    }

    while (queue.length > 0 && visible_entries.length < view_num) {
      const entry = queue.shift()
      if (!entry) continue
      visible_entries.push(entry)

      const entry_path = Object.keys(entries).find(key => entries[key] === entry)
      // Handle subs
      if (expanded_subs.has(entry_path) && entry.subs && entry.subs.length > 0) {
        queue = [...entry.subs.map(path => entries[path]), ...queue]
      }
      // Handle hubs (supers)
      if (expanded_supers.has(entry_path) && entry.hubs && entry.hubs.length > 0) {
        queue = [...entry.hubs.map(path => entries[path]), ...queue]
      }
    }
    
    return visible_entries
  }
  /******************************************************************************
  Create a node element for the explorer tree.
  ******************************************************************************/
  function create_node(entry) {
    const node = document.createElement('div')
    const entry_path = Object.keys(entries).find(key => entries[key] === entry)

    const depth = calculate_depth(entry_path)
    const is_expanded = expanded_subs.has(entry_path)
    const is_super_expanded = expanded_supers.has(entry_path)

    const parent_path_split = entry_path.split('/')
    parent_path_split.pop()
    const parent_path = parent_path_split.join('/') || '/'
    const parent_entry = entries[parent_path] || entries['/']
    const parent_sub_num = parent_entry.subs ? parent_entry.subs.length - 1: 0
    const is_last = entry_path === entries[parent_path]?.subs?.[ parent_sub_num ]

    const has_children = entry.subs && entry.subs.length > 0

    let icon_class = get_icon_class_for_type(entry.type)
    let prefix = create_tree_prefix(depth, is_expanded, is_last, ignore_depth)

    node.className = 'explorer-node'
    node.dataset.path = entry_path
    node.dataset.index = entry_path
    node.style.paddingLeft = `17px`

    node.innerHTML = `
      <span class="tree-prefix">${prefix}</span>
      <span class="node-icon ${icon_class}"></span>
      <span class="node-name">${entry.name}</span>
    `

    const prefix_el = node.querySelector('.tree-prefix')
    const icon_el = node.querySelector('.node-icon')

    if (has_children) {
      icon_el.onclick = () => toggle_subs(entry)
    }
    // TODO: finish this
    prefix_el.onclick = () => toggle_super(entry)

    return node
  }

  function toggle_subs(entry) {
    const path = Object.keys(entries).find(key => entries[key] === entry)
    
    if (expanded_subs.has(path)) {
      expanded_subs.delete(path)
    } else {
      expanded_subs.add(path)
    }
    render_visible_nodes()
    // console.log('view:', view)
    // console.log('view:', view_num)
  }

  function toggle_super(entry) {
    const path = Object.keys(entries).find(key => entries[key] === entry)
    if (expanded_supers.has(path)) {
      expanded_supers.delete(path)
    } else {
      expanded_supers.add(path)
    }
    render_visible_nodes()
  }

  // Get appropriate CSS class for entry type
  function get_icon_class_for_type(type) {
    const type_classes = {
      'root': 'icon-root',
      'folder': 'icon-folder',
      'file': 'icon-file',
      'html-file': 'icon-html-file',
      'js-file': 'icon-js-file',
      'css-file': 'icon-css-file',
      'json-file': 'icon-json-file'
    }
    
    return type_classes[type] || 'icon-file'
  }
  /******************************************************************************
   Prefix creation for tree structure.
   //TODO: Add support for different icons based on entry type.
  /******************************************************************************/
  function create_tree_prefix(depth, is_expanded, is_last, ignore_depth) {
    let pipe = ''
    while (depth > 0) {
      // console.log('depth:', depth, ignore_depth.includes(depth))
      // pipe += ignore_depth.includes(depth) ? ' ' : '│'
      // console.log('pipe:', pipe)
      pipe += '│'
      depth--
    }
    const prefix = is_expanded ? (is_last ? '└┬' : '├┬') : (is_last ? '└─' : '├─')
    return `${pipe}${prefix}`
  }

  function calculate_depth(path) {
    if (!path) return 0
    return (path.match(/\//g) || []).length - 1
  }
}

function fallback_module() {
  return {
    api: fallback_instance
  }
  
  function fallback_instance() {
    return {
      drive: {
        'style/': {
          'theme.css': {
            raw: `
              .graph-explorer {
                height: 300px;
                font-family: monospace;
                color: #eee;
                background-color: #2d3440;
                display: flex;
                flex-direction: column;
                overflow: auto;
                user-select: none;
              }
                
              .explorer-container {
                height: 100%;
              }
              
              .explorer-node {
                display: flex;
                align-items: center;
                // padding: 2px 0;ssssssssssssssssssss
                white-space: nowrap;
                cursor: pointer;
              }
              
              .explorer-node:hover {
                background-color: rgba(255, 255, 255, 0.1);
              }
              
              .tree-prefix {
                margin-right: 4px;
                opacity: 0.7;
                cursor: pointer;
              }
              
              .node-icon {
                margin-right: 6px;
                cursor: pointer;
              }
              
              .node-icon::before {
                font-style: normal;
              }
              
              .icon-root::before {
                content: "🌐";
              }
              
              .icon-folder::before {
                content: "📁";
              }
              
              .icon-file::before {
                content: "📄";
              }
              
              .icon-html-file::before {
                content: "📄";
              }             
              .icon-js-file::before {
                content: "📄";
              }              
              .icon-css-file::before {
                content: "🖌️";
              }              
              .icon-json-file::before {
                content: "🎨";
              }              
              .node-name {
                overflow: hidden;
                text-overflow: ellipsis;
              }
            `
          }
        },
        'entries/': {
          'graph.json': {
            '$ref': 'entries.json'
          }
        }
      }
    }
  }
}
