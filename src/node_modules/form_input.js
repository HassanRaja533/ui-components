const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = form_input
async function form_input (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const {drive} = sdb
	
	const on = {
    style: inject,
    data: ondata
  }

  let current_step = null
  let input_accessible = true
	
	if(protocol){
    send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="input-display">
    <div class='test'>
      <input class="input-field" type="text" placeholder="Type to submit">
    </div>
    <div class="overlay-lock" hidden></div>
  </div>
  <style>
  </style>`
  const style = shadow.querySelector('style')
  
	const input_field_el = shadow.querySelector('.input-field')
  const overlay_el = shadow.querySelector('.overlay-lock')

	input_field_el.oninput = async function () {
    if (!input_accessible) return
    await drive.put('data/form_input.json', {
      input_field: this.value
    })
		if (this.value.length >= 10) {
			_.up({
        type: 'action_submitted',
        data: {
          value: this.value,
          index: current_step?.index || 0
        }
      })
			console.log('mark_as_complete')
		}
	}

  const subs = await sdb.watch(onbatch)

  
  return el

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }

  function inject (data) {
    style.replaceChildren((() => {
      return document.createElement('style').textContent = data[0]
    })())
  }

  function ondata(data) {
    if (data && data.length > 0) {
      const input_data = data[0]
      if (input_data && input_data.input_field) {
        input_field_el.value = input_data.input_field
      }
    } else {
      input_field_el.value = ''
    }
  }

	function onmessage ({ type, data }) {
    console.log('message from form_input', type, data)
    if (type === 'step_data') {
      current_step = data
      input_accessible = data?.is_accessible !== false
      
      overlay_el.hidden = input_accessible

      input_field_el.placeholder = input_accessible
        ? 'Type to submit'
        : 'Input disabled for this step'
    }
  }

}
function fallback_module () {
  return {
    api: fallback_instance,
  }
  function fallback_instance () {
    return {
      drive: {
        'style/': {
          'theme.css': {
            raw: `
            .input-display {
              position: relative;
							background: #131315;
              border-radius: 16px;
              border: 1px solid #3c3c3c;
							display: flex;
							flex: 1;
							align-items: center;
							padding: 0 12px;
							min-height: 32px;
            }
						.input-display:focus-within {
							border-color: #4285f4;
							background: #1a1a1c;
            }	
						.input-field {
							flex: 1;
							min-height: 32px;
							background: transparent;
							border: none;
							color: #e8eaed;
							padding: 0 12px;
							font-size: 14px;
							outline: none;
						}
						.input-field::placeholder {
							color: #a6a6a6;
						}
            .overlay-lock {
              position: absolute;
              inset: 0;
              background: transparent;
              z-index: 10;
              cursor: not-allowed;
            }
						`
          }
        },
        'data/': {
          'form_input.json': {
            raw:  {
              input_field: ""
            }
          }
        }
      }
    }
  }
}
