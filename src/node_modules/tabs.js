const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, subs: [get] } = statedb(fallback_module)
module.exports = component
async function component(opts, btnobj = [
  {
    label: 'btn1',
     icon: 'icon1',
     callback : function func1(){ return console.log('btn1')}
  },
  {
    label: 'btn2',
    icon: 'icon2',
    callback : function func2(){ return console.log('btn2')}
  }
]) {
  const { id, sdb } = await get(opts.sid)
  const on = {
    style: inject
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `<div class="tab-entries"></div>`
  const entries = shadow.querySelector('.tab-entries')
  btnobj.forEach(create_btn)
  const subs = await sdb.watch(onbatch)
  return div
  async function create_btn ({icon, label, callback}) {
    const reqico = await load_svg(`/ui-components/src/assets/icons/${icon}.svg`)
    const cross_icon = await load_svg(`/ui-components/src/assets/icons/cross.svg`)
    // const reqico = await load_svg(`src/assets/icons/${icon}.svg`)
    // const cross_icon = await load_svg(`src/assets/icons/cross.svg`)

    const el = document.createElement('div')
    el.innerHTML = `
    <span class="icon">${reqico}</span>
    <span class="label">${label}</span>
    <button class="btn">${cross_icon}</button>`

    el.className = 'tabsbtn'
    const icon_el = el.querySelector('.icon')
    const label_el = el.querySelector('.label')

    label_el.draggable = false
    icon_el.onclick = callback
    entries.onwheel = (e) => {
      if(entries.scrollWidth > entries.clientWidth) {
      e.preventDefault()
      entries.scrollLeft += e.deltaY/20
      }
    }
    entries.appendChild(el)
    return
  }
  async function load_svg(svg_url) {
    const response = await fetch(svg_url)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    const text_svg = await response.text()
    return text_svg
  }
  function onbatch (batch) {
    for (const { type, data } of batch) {
      on[type] && on[type](data)
    }
  }
  function inject(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }
}
function fallback_module() {
  return {
    api: fallback_instance,
  }
  function fallback_instance() {
    return {
      drive: {
        style: {
          'theme.css': {
            raw: `
            .tab-entries {
              display: flex;
              flex-direction: row;
              justify-content: flex-start;
              align-items: center;
              align-content: center;
              flex-wrap: nowrap;
              overflow-x: hidden;
              background-color: #131315;
              column-gap: 14px;
              padding: 10px 2px;
            }
            .tabsbtn {
              display: flex;
              flex-direction: row;
              flex-wrap: nowrap;
              align-items: center;
              background-color: #191919;
              padding: 8px 14px;
              border-radius: 30px;
            }
            .icon {
              margin-right: 5px;
            }
            .label {
              font-size: 14px;
              margin-right: 5px;
              user-select: none;
              color: #a6a6a6;
            }
            .btn {
              border: none;
              display: flex;
              padding: 0;
              background-color: transparent;
            }
            `
          }
        }
      }
    }
  }
}