const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)
module.exports = component
async function component(opts, callback = id => console.log('calling:', '@' + id)) {
  const { id, sdb } = await get(opts.sid)
  const on = {
    variables: onvariables,
    style: inject
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `<div class="tab-entries"></div>`
  const entries = shadow.querySelector('.tab-entries')
  let dricons = {}
  const subs = await sdb.watch(onbatch)
  if (entries) {
    let is_down = false
    let start_x
    let scroll_left_start

    entries.onmousedown = (e) => {
      if (entries.scrollWidth <= entries.clientWidth) return

      is_down = true
      entries.classList.add('grabbing')
      start_x = e.pageX - entries.offsetLeft
      scroll_left_start = entries.scrollLeft
    }

    entries.onmouseleave = () => {
      if (!is_down) return
      is_down = false
      entries.classList.remove('grabbing')
    }

    window.onmouseup = () => {
      if (!is_down) return
      is_down = false
      entries.classList.remove('grabbing')
    }

    entries.onmousemove = (e) => {
      if (!is_down) return

      if (entries.scrollWidth <= entries.clientWidth) {
        is_down = false
        entries.classList.remove('grabbing')
        return
      }

      e.preventDefault()

      const x = e.pageX - entries.offsetLeft
      const walk = (x - start_x) * 1.5
      entries.scrollLeft = scroll_left_start - walk
    }

    entries.ontouchstart = (e) => {
      if (entries.scrollWidth <= entries.clientWidth) return

      is_down = true
      start_x = e.touches[0].pageX - entries.offsetLeft
      scroll_left_start = entries.scrollLeft
    }

    entries.ontouchend = () => {
      if (!is_down) return
      is_down = false
    }

    entries.ontouchcancel = () => {
      if (!is_down) return
      is_down = false
    }

    entries.ontouchmove = (e) => {
      if (!is_down) return

      if (entries.scrollWidth <= entries.clientWidth) {
        is_down = false
        return
      }

      e.preventDefault()
      const x = e.touches[0].pageX - entries.offsetLeft
      const walk = (x - start_x) * 1.5
      entries.scrollLeft = scroll_left_start - walk
    }
  }
  return div
  async function create_btn ({name, id},index) {
    const el = document.createElement('div')
    el.innerHTML = `
    <div class="first-half">
      <span class="icon">${dricons[index + 1]}</span>
      <span class="name">${id}</span>
    </div>
    <span class="name">${name}</span>
    <button class="btn">${dricons[0]}</button>`

    el.className = 'tabsbtn'
    const first_half = el.querySelector('.first-half')
    const label_el = el.querySelector('.name')

    label_el.draggable = false
    first_half.onclick = exec => callback(id + name)
    entries.appendChild(el)
    return
  }
  function onbatch (batch) {
    iconject(batch[2].data)
    for (const { type, data } of batch) {
      on[type] && on[type](data)
    }
  }
  function inject(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }
  function iconject(data) {
    dricons = data
  }
  function onvariables (data) {
    if(typeof data[0] === 'string') {
      const variables = JSON.parse(data[0])
      variables.forEach(create_btn)
      return
    }
    data[0].forEach(create_btn)
  }
}
function fallback_module() {
  return {
    api: fallback_instance,
  }
  function fallback_instance() {
    return {
      drive: {
        'icons/': {
          'cross.svg':{
            '$ref': 'cross.svg'
          },
          '1.svg': {
            '$ref': 'icon.svg'
          },
          '2.svg': {
            '$ref': 'icon.svg'
          },
          '3.svg': {
            '$ref': 'icon.svg'
          }
        },
        'variables/': {
          'tabs.json': {
            '$ref': 'tabs.json'
          }
        },
        style: {
          'theme.css': {
            '$ref': 'style.css'
          }
        }
      }
    }
  }
}