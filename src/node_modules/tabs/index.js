const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)
module.exports = component
async function component(opts, callback) {
  const { id, sdb } = await get(opts.sid)
  const on = {
    variables: onvariables,
    style: inject,
    icons: iconject
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `<div class="tab-entries"></div>`
  const entries = shadow.querySelector('.tab-entries')
  let dricons = {}
  const subs = await sdb.watch(onbatch)
  return div
  async function create_btn ({name, id},index) {
    const el = document.createElement('div')
    el.innerHTML = `
    <span class="icon">${dricons[index + 1]}</span>
    <span class='name'>${id}</span>
    <span class="name">${name}</span>
    <button class="btn">${dricons[0]}</button>`

    el.className = 'tabsbtn'
    const icon_el = el.querySelector('.icon')
    const label_el = el.querySelector('.name')

    label_el.draggable = false
    icon_el.onclick = callback
    entries.onwheel = (e) => {
      if(entries.scrollWidth > entries.clientWidth) {
      e.preventDefault()
      entries.scrollLeft += e.deltaY/20
      }
    }
    entries.appendChild(el)
    return
  }
  async function load_svg(svg_url) {
    const response = await fetch(svg_url)
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    const text_svg = await response.text()
    return text_svg
  }
  function onbatch (batch) {
    for (const { type, data } of batch) {
      on[type] && on[type](data)
    }
  }
  function inject(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }
  function onvariables (data) {
    data[0].forEach( create_btn)
  }
  function iconject(data) {
    dricons = data
  }
}
function fallback_module() {
  return {
    api: fallback_instance,
  }
  function fallback_instance() {
    return {
      drive: {
        'icons/': {
          'cross.svg':{
            '$ref': 'cross.svg'
          },
          '1.svg': {
            '$ref': 'icon.svg'
          },
          '2.svg': {
            '$ref': 'icon.svg'
          },
          '3.svg': {
            '$ref': 'icon.svg'
          }
        },
        'variables/': {
          'tabs.json': {
            '$ref': 'tabs.json'
          }
        },
        'style/': {
          'theme.css': {
            raw: `
            .tab-entries {
              display: flex;
              flex-direction: row;
              justify-content: flex-start;
              align-items: center;
              align-content: center;
              flex-wrap: nowrap;
              overflow-x: hidden;
              background-color: #131315;
              column-gap: 14px;
              padding: 10px 2px;
            }
            .tabsbtn {
              display: flex;
              flex-direction: row;
              flex-wrap: nowrap;
              align-items: center;
              background-color: #191919;
              padding: 8px 14px;
              border-radius: 30px;
            }
            .icon {
              margin-right: 5px;
            }
            .name {
              font-size: 14px;
              margin-right: 5px;
              user-select: none;
              color: #a6a6a6;
            }
            .btn {
              border: none;
              display: flex;
              padding: 0;
              background-color: transparent;
              color: #ffffff;
            }
            svg.btn{
              width: 25px;
              height: 25px;
            }
            svg{
              width: 20px;
              height: 20px;
            }
            `
          }
        }
      }
    }
  }
}