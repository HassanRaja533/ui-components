const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)
module.exports = component

async function component(opts, callback = id => console.log('calling:', '@' + id)) {
  const { id, sdb } = await get(opts.sid)
  const on = {
    variables: onvariables,
    style: inject,
    icons: iconject,
    scroll: onscroll
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `<div class="tab-entries"></div>`
  const entries = shadow.querySelector('.tab-entries')
  
  console.log(await sdb.drive({type: 'scroll'}).get('position.json'))
  console.log(sdb.drive({type: 'scroll'}).put('position.json', 5))
  /**************************************** 
   console.log('%c TABS COMPONENT INITIALIZED ', 'background: #222; color: #bada55; font-size: 24px; font-weight: bold;')
   ****************************************/
  
  let state = {
    hasIcons: false,
    hasVariables: false,
    icons: {},
    variables: null
  }
  
  
  const subs = await sdb.watch(onbatch)
  if (entries) {
    let is_down = false
    let start_x
    let scroll_left_start
    
    const handleMouseMove = (e) => {
      if (!is_down) return

      if (entries.scrollWidth <= entries.clientWidth) {
        is_down = false
        entries.classList.remove('grabbing')
        return
      }

      e.preventDefault()
      const x = e.pageX - entries.offsetLeft
      const walk = (x - start_x) * 1.5
      entries.scrollLeft = scroll_left_start - walk
    }

    const handleMouseUp = () => {
      if (!is_down) return
      is_down = false
      entries.classList.remove('grabbing')
      update_scroll_position()
      window.onmousemove = null
      window.onmouseup = null
    }
    
    entries.onmousedown = (e) => {
      if (entries.scrollWidth <= entries.clientWidth) return
      
      is_down = true
      entries.classList.add('grabbing')
      start_x = e.pageX - entries.offsetLeft
      scroll_left_start = entries.scrollLeft
      
      window.onmousemove = handleMouseMove
      window.onmouseup = handleMouseUp
    }

    entries.onmouseleave = () => {
      if (!is_down) return
      is_down = false
      entries.classList.remove('grabbing')
      update_scroll_position()
    }

    entries.ontouchstart = (e) => {
      if (entries.scrollWidth <= entries.clientWidth) return

      is_down = true
      start_x = e.touches[0].pageX - entries.offsetLeft
      scroll_left_start = entries.scrollLeft
    }

    entries.ontouchend = () => {
      if (!is_down) return
      is_down = false
      update_scroll_position()
    }
    
    entries.ontouchcancel = () => {
      if (!is_down) return
      is_down = false
      update_scroll_position()
    }

    entries.ontouchmove = (e) => {
      if (!is_down) return

      if (entries.scrollWidth <= entries.clientWidth) {
        is_down = false
        return
      }

      e.preventDefault()
      const x = e.touches[0].pageX - entries.offsetLeft
      const walk = (x - start_x) * 1.5
      entries.scrollLeft = scroll_left_start - walk
    }
  }
  return div
  
  async function create_btn({ name, id }, index) {
    if (!state.hasIcons) {
      console.warn('Trying to create button before icons are loaded')
      return
    }

    const el = document.createElement('div')
    el.innerHTML = `
    <span class="icon">${state.icons[index + 1]}</span>
    <span class='name'>${id}</span>
    <span class="name">${name}</span>
    <button class="btn">${state.icons[0]}</button>`

    el.className = 'tabsbtn'
    const icon_el = el.querySelector('.icon')
    const label_el = el.querySelector('.name')

    label_el.draggable = false
    icon_el.onclick = callback
    entries.appendChild(el)
    return
  }

  function onbatch (batch) {
    for (const { type, data } of batch) {
      if (type === 'scroll') {
        onscroll(data)
      }
    }
    
    for (const { type, data } of batch) {
      if (type === 'icons') {
        iconject(data)
      }
      if (type === 'variables') {
        state.variables = data
      }
    }

    for (const { type, data } of batch) {
      if (type !== 'icons' && type !== 'variables' && type !== 'scroll') {
        on[type] && on[type](data) 
      }
    }

    if (state.hasIcons && state.variables && !state.hasVariables) {
      onvariables(state.variables)
    }
  }

  function inject(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }

  function onvariables(data) {
    if (!state.hasIcons) {
      console.warn('Variables received before icons, storing for later')
      state.variables = data
      return
    }

    if(typeof data[0] === 'string') {
      const variables = JSON.parse(data[0])
      variables.forEach(create_btn)
    } else {
      data[0].forEach(create_btn)
    }
    state.hasVariables = true
    state.variables = null
  }

  function iconject(data) {
    state.icons = data
    state.hasIcons = true

    if (state.variables) {
      onvariables(state.variables)
    }
  }

  function update_scroll_position() {
  }

  function onscroll(data) {
    if (entries) {
      entries.scrollLeft = data
    }
  }
}

function fallback_module() {
  return {
    api: fallback_instance,
  }
  function fallback_instance() {
    return {
      drive: {
        'icons/': {
          'cross.svg':{
            '$ref': 'cross.svg'
          },
          '1.svg': {
            '$ref': 'icon.svg'
          },
          '2.svg': {
            '$ref': 'icon.svg'
          },
          '3.svg': {
            '$ref': 'icon.svg'
          }
        },
        'variables/': {
          'tabs.json': {
            '$ref': 'tabs.json'
          }
        },
        'scroll/': {
          'position.json': {
            raw: '0'
          }
        },
        'style/': {
          'theme.css': {
            '$ref': 'style.css'
          }
        }
      }
    }
  }
}