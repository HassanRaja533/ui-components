const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)
module.exports = component

async function component (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb
  const on = {
    variables: onvariables,
    style: inject,
    icons: iconject,
    scroll: onscroll
  }
  const div = document.createElement('div')
  const shadow = div.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="tab-entries main"></div>
  <style>
  </style>`
  const entries = shadow.querySelector('.tab-entries')
  const style = shadow.querySelector('style')
  const main = shadow.querySelector('.main')

  
  let init = false
  let variables = []
  let dricons = []
  let current_id = null       
  let highlight_target = null
  const subs = await sdb.watch(onbatch)
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }
  if (entries) {
    let is_down = false
    let start_x
    let scroll_start

    const stop = () => {
      is_down = false
      entries.classList.remove('grabbing')
      update_scroll_position()
    }

    const move = x => {
      if (!is_down) return
      if (entries.scrollWidth <= entries.clientWidth) return stop()
      entries.scrollLeft = scroll_start - (x - start_x) * 1.5
    }

    entries.onmousedown = e => {
      if (entries.scrollWidth <= entries.clientWidth) return
      is_down = true
      entries.classList.add('grabbing')
      start_x = e.pageX - entries.offsetLeft
      scroll_start = entries.scrollLeft
      window.onmousemove = e => {
        move(e.pageX - entries.offsetLeft)
        e.preventDefault()
      }
      window.onmouseup = () => {
        stop()
        window.onmousemove = window.onmouseup = null
      }
    }

    entries.onmouseleave = stop

    entries.ontouchstart = e => {
      if (entries.scrollWidth <= entries.clientWidth) return
      is_down = true
      start_x = e.touches[0].pageX - entries.offsetLeft
      scroll_start = entries.scrollLeft
    }
    ;['ontouchend', 'ontouchcancel'].forEach(ev => {
      entries[ev] = stop
    })

    entries.ontouchmove = e => {
      move(e.touches[0].pageX - entries.offsetLeft)
      e.preventDefault()
    }
  }
  return div

  function onmessage({ type, data }) {
    switch (type) {
      default:
        // Handle other message types
    }
  }

  async function create_btn ({ name, id }, index) {
    const el = document.createElement('div')
    el.innerHTML = `
    <span class="icon">${dricons[index + 1]}</span>
    <span class='name'>${id}</span>
    <span class="name">${name}</span>
    <button class="btn">${dricons[0]}</button>`

    el.className = 'tabsbtn'
    const icon_el = el.querySelector('.icon')
    const name_el = el.querySelector('.name');
    const close_btn = el.querySelector('.btn')

    name_el.draggable = false;
    
    // Click on icon
   icon_el.onclick = () => {
     current_id = id;
     highlight_target = 'icon';
     update_tab_highlight();

     if (_) {
      _.up({ type: 'tab_icon_clicked', data: { id , name} })
     }
   };


// Click on name
   name_el.onclick = () => {
     current_id = id;
     highlight_target = 'name';
     update_tab_highlight();
     if (_) {
      _.up({ type: 'tab_name_clicked', data: { id, name } })
     }
   };

    // Add click handler for close button
   close_btn.onclick = (e) => {
     e.stopPropagation()
     if (_) {
       _.up({ type: 'tab_close_clicked', data: { id, name } })
      }
   }
    
    entries.appendChild(el)
    return
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init) {
      variables.forEach(create_btn)
      init = true
    } else {
      // TODO: Here we can handle drive updates
    }
  }
  function fail (data, type) { throw new Error('invalid message', { cause: { data, type } }) }
  function inject (data) {
    style.innerHTML = data.join('\n')
  }

  function onvariables (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    variables = vars
  }

  function iconject (data) {
    dricons = data
  }

  function update_scroll_position () {
    // TODO
  }

  function onscroll (data) {
    setTimeout(() => {
      if (entries) {
        entries.scrollLeft = data
      }
    }, 200)
  }

  function update_tab_highlight () {
    const all_tabs = entries.querySelectorAll('.tabsbtn')
    all_tabs.forEach(tab => {
      tab.classList.remove('active-border')
      tab.querySelectorAll('.name').forEach(n => n.classList.remove('active-name'))
      tab.querySelector('.icon')?.classList.remove('active-icon')
    })

     const target_tab = Array.from(all_tabs).find(tab => {
     const names = tab.querySelectorAll('.name')
     return Array.from(names).some(n => n.textContent === current_id)
    })

    target_tab.classList.add('active-border');

    if (highlight_target === 'name') {
      target_tab.querySelectorAll('.name').forEach(n => n.classList.add('active-name'))
    }

    if (highlight_target === 'icon') {
      target_tab.querySelector('.icon')?.classList.add('active-icon')
    }
  }
}



function fallback_module () {
  return {
    api: fallback_instance,
  }
  function fallback_instance () {
    return {
      drive: {
        'icons/': {
          'cross.svg': {
            '$ref': 'cross.svg'
          },
          '1.svg': {
            '$ref': 'icon.svg'
          },
          '2.svg': {
            '$ref': 'icon.svg'
          },
          '3.svg': {
            '$ref': 'icon.svg'
          }
        },
        'variables/': {
          'tabs.json': {
            '$ref': 'tabs.json'
          }
        },
        'scroll/': {
          'position.json': {
            raw: '100'
          }
        },
        'style/': {
          'theme.css': {
            raw: `
              .first-half {
                display: flex;
                flex-direction: row;
                align-items: center;
                flex-wrap: nowrap;
              }
              .tab-entries {
                display: flex;
                flex-direction: row;
                flex: auto;
                justify-content: flex-start;
                align-items: center;
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: hidden;
                background-color: #131315;
                column-gap: 9px;
                padding: 10px 10px;
                scrollbar-width: 10%;
                -ms-overflow-style: none;
                position: relative;
              }
              .tab-entries::-webkit-scrollbar {
                height: 2px;
                background: transparent;
              }
              .tab-entries::-webkit-scrollbar-thumb {
                background-color: white;
                border-radius: 2px;
                visibility: hidden;
              }
              .tab-entries::-webkit-scrollbar-track {
                background: transparent;
              }
             .tab-entries:hover::-webkit-scrollbar-thumb {
                visibility: visible;
              }
              .tabsbtn {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                align-items: center;
                background-color: #191919;
                padding: 8px 14px;
                border-radius: 30px;
                max-width: 100%;                 
                min-width: 0;                    
                flex-shrink: 0;  
                position: relative;     
                transition: background-color 0.2s ease-in-out;           
              }
              .tabsbtn:hover {
                background-color: #2a2a2a;
              } 
              .tabsbtn.active-border {
                outline: 1px solid white;
              }       
              .icon {
                margin-right: 5px;
                display: flex;
                font-weight: bold;
              }
              .name {
                display: inline-block;
                max-width: 100px;               
                overflow: hidden;               
                text-overflow: ellipsis;        
                white-space: nowrap;            
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;  
                font-size: 14px;
                font-weight: bold;              
                color: #a6a6a6;
                user-select: none;
              }
              .btn {
                border: none;
                display: flex;
                background-color: transparent;
                color: #ffffff;
              }
              svg{
                width: 20px;
                height: 20px;
                flex-shrink: 0;  
              }
              .name.active-name {
                color: white;
              }
              .icon.active-icon svg {
                filter: brightness(2);
              }
            `
          }
        }
      }
    }
  }
}
