const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = steps_wizard

async function steps_wizard (opts) {
  const { id, sdb } = await get(opts.sid)
  const {drive} = sdb
  
  const on = {
    style: inject,
    variables: onvariables,
  }

  let variables = []

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="steps-wizard main">
    <div class="steps-slot"></div>
  </div>
  <style>
  </style>
  `

  const style = shadow.querySelector('style')
  const steps_entries = shadow.querySelector('.steps-slot')

  const subs = await sdb.watch(onbatch)

  return el
  
  function render_steps(steps) {
    if (!steps)
      return;
    steps_entries.innerHTML = '';

    steps.forEach((step, index) => {
      const btn = document.createElement('button');
      btn.className = 'step-button';
      btn.textContent = step.name + (step.type === 'optional' ? ' *' : '');
      btn.setAttribute('data-step', index + 1);

      const accessible = can_access(index, steps);

      let status = 'default';
      if (!accessible) status = 'disabled';
      else if (step.is_completed) status = 'completed';
      else if (step.status === 'error') status = 'error';
      else if (step.type === 'optional') status = 'optional';

      btn.classList.add(`step-${status}`);
      btn.disabled = (status === 'disabled');

      btn.onclick = () => {
        if (!btn.disabled) {
          step.is_completed = true
          step.status = 'completed';
          console.log('Clicked:', step);
          drive.put('variables/steps_wizard.json', {'change_path': steps})
        }
      };

      steps_entries.appendChild(btn);
    });
    
  }

  function can_access(index, steps) {
    for (let i = 0; i < index; i++) {
      if (!steps[i].is_completed && steps[i].type !== 'optional') {
        return false;
      }
    }

    return true;
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }
  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }
  function inject (data) {
    style.replaceChildren((() => {
      return document.createElement('style').textContent = data[0]
    })())
  }

  function onvariables (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    variables = vars['change_path'] 
    render_steps(variables);
  }

}

function fallback_module () {
  return {
    api: fallback_instance
  }

  function fallback_instance () {
    return {
      drive: {
        'style/': {
          'stepswizard.css': {
            '$ref': 'stepswizard.css' 
          }
        },
        'variables/': {
          'steps_wizard.json': {
            '$ref': 'steps_wizard.json'
          }
        },
      }
    }
  }
}
