const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

const quick_actions = require('quick_actions')
const actions = require('actions')

module.exports = steps_wizard

async function steps_wizard (opts) {
  const { id, sdb } = await get(opts.sid)
  const {drive} = sdb
  
  const on = {
    style: inject,
    variables: onvariables,
  }

  let variables = []
  let current_step = 1;

  let _ = {send_quick_actions: null}

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="steps-wizard main">
    <div class="actions"></div>
    <div class="steps-slot hide"></div>
    <div class="quick-actions"></div>
  </div>
  <style>
  </style>
  `

  const style = shadow.querySelector('style')
  const steps_entries = shadow.querySelector('.steps-slot')
  const quick_actions_placeholder = shadow.querySelector('.quick-actions')
  const actions_placeholder = shadow.querySelector('.actions')

  const subs = await sdb.watch(onbatch)

  const quick_actions_el = await quick_actions(subs[0], quick_actions_protocol)
  quick_actions_placeholder.replaceWith(quick_actions_el)

  const actions_el = await actions(subs[1], actions_protocol)
  actions_el.classList.add('hide')
  actions_placeholder.replaceWith(actions_el)

  return el
  
  function render_steps(steps) {
    if (!steps)
      return;

    steps_entries.innerHTML = '';

    steps.forEach((step, index) => {
      const btn = document.createElement('button');
      btn.className = 'step-button';
      btn.textContent = step.name + (step.type === 'optional' ? ' *' : '');
      btn.setAttribute('data-step', index + 1);

      const accessible = can_access(index, steps);

      let status = 'default';
      if (!accessible) status = 'disabled';
      else if (step.is_completed) status = 'completed';
      else if (step.status === 'error') status = 'error';
      else if (step.type === 'optional') status = 'optional';

      btn.classList.add(`step-${status}`);
      btn.disabled = (status === 'disabled');

      if (accessible) {
        current_step = index + 1;
      }

      btn.onclick = () => {
        if (!btn.disabled) {
          console.log('Clicked:', step);
        }
      };

      steps_entries.appendChild(btn);
    });

    if (_.send_quick_actions) {
      _.send_quick_actions({
        type: 'update_steps',
        data: {
          current_step: current_step,
          total_steps: steps.length
        }
      });
    }
    
  }

  function can_access(index, steps) {
    for (let i = 0; i < index; i++) {
      if (!steps[i].is_completed && steps[i].type !== 'optional') {
        return false;
      }
    }

    return true;
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }
  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }
  function inject (data) {
    style.replaceChildren((() => {
      return document.createElement('style').textContent = data[0]
    })())
  }

  function onvariables (data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    variables = vars['change_path'] 
    render_steps(variables);
  }


  function cleanup () {
    const cleaned = variables.map(step => ({
      ...step,
      is_completed: false
    }));

    drive.put('variables/steps_wizard.json', { change_path: cleaned });
  }
  // ---- Toggle Views ----
  function toggle_view(el, show) {
    el.classList.toggle('hide', !show);
  }

  function steps_toggle_view(display) {
    toggle_view(steps_entries, display === 'block');
  }

  function actions_toggle_view(display) {
    toggle_view(actions_el, display === 'block');
  }

  // ---- Protocols ----
  function actions_protocol (send) {
    _.send_actions = send
    return on
    function on ({ type, data }) { 
      console.log('actions data', type, data)
      _.send_quick_actions({
        type,
        data: {
        ...data,
        current_step: current_step,
        total_steps: variables.length
        }
      })
      
      steps_toggle_view('block')
      actions_toggle_view('hide')
    }
  }

  function quick_actions_protocol (send) {
    _.send_quick_actions = send
    return on
    function on ({ type, data }) {
      onmessage({type, data})
    }
  }
  
  function onmessage ({ type, data }) {
    if (type == 'display_actions') {
      actions_toggle_view(data)
      if (data === 'none') {
        steps_toggle_view(data)
        cleanup()
      }
    } else if (type == 'action_submitted') {
      const step = variables[data.current_step - 1]
      Object.assign(step, {
        is_completed: true,
        status: 'completed'
      })
      drive.put('variables/steps_wizard.json', {change_path : variables})
    }
  }

}



function fallback_module () {
  return {
    api: fallback_instance,
    _: {
      'quick_actions': {
        $: ''
      },
      'actions': {
        $: ''
      },
    }
  }

  function fallback_instance () {
    return {
      _: {
        'quick_actions': {
          0: '',
          mapping: {
            'style': 'style',
            'icons': 'icons',
            'actions': 'actions',
            'hardcons': 'hardcons'
          }
        },
        'actions': {
          0: '',
          mapping: {
            'style': 'style',
            'actions': 'actions',
            'icons': 'icons',
            'hardcons': 'hardcons'
          }
        },
      },
      drive: {
        'style/': {
          'stepswizard.css': {
            '$ref': 'stepswizard.css' 
          }
        },
        'variables/': {
          'steps_wizard.json': {
            '$ref': 'steps_wizard.json'
          }
        },
      }
    }
  }
}
