const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)


module.exports = program

async function program(opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject,
    variables: onvariables,
  }

  const _ = {
    up: null,
  }

  if (protocol) {
    const send = protocol((msg) => onmessage(msg))
    _.up = send
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
    <style></style>
  `

  const style = shadow.querySelector('style')
  
  const subs = await sdb.watch(onbatch)

  return el

  // --- Internal Functions ---
  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail(data, type) {
    throw new Error('invalid message', { cause: { data, type } })
  }

  function inject(data) {
    style.replaceChildren((() => {
      return document.createElement('style').textContent = data[0]
    })())
  }

  function onvariables(data) {
    const vars = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
    _?.up({
      type: 'load_actions',
      data: vars,
    })
  }

  function onmessage({ type, data }) {
    if (type == 'display_result') {
      console.log('Display Result:', data)
    }
  }
}

// --- Fallback Module ---
function fallback_module() {
  return {
    api: fallback_instance,
  }

  function fallback_instance() {
    return {
      drive: {
        'style/': {
          'program.css': { 
            raw: `
              .main {
                display: flex;
                flex-direction: column;
                align-items: center;
              }
            ` 
          }
        },
        'variables/': {
          'program.json': { '$ref': 'program.json' }
        }
      }
    }
  }
}
